using UnityEngine;using System.Collections;using System.Collections.Generic;using Assets.scripts.UI.screen.ingame;namespace Assets.scripts.camera {	public class MainCamera : MonoBehaviour {		public float cameraMovementSpeed = .5f;		public bool smoothMove = true;		public float factor;		//  player is placing objects in to the scene		public bool isPlacing = false;		// points where camera can move		public Transform[] cameraSteps = new Transform[10];		private Vector3 startPos, endPos; // we should get ride of this		private bool freeMove = false; // we should get ride of this		Vector3 lastPos; // we should get ride of this		private int currentCameraStepIndex = 0;		private Vector3 cameraStart;		private Vector3 cameraDestination;		private float cameraMovementFraction = 1;		// this is blocking the camera from moving while dragging (and touchBlocked blocks camera movement right after drag drop);		List<Draggable> draggable = new List<Draggable>();		bool somethingIsDragged = false, touchBlocked = false;		void Start() {			ToolButtons [] os = GameObject.FindObjectsOfType<ToolButtons>();			foreach ( ToolButtons o in os ) {				draggable.Add((Draggable) o);			}		}		// Update is called once per frame		void Update() {			// hot fix for preventing camera movement when dragging objects into scene			foreach(Draggable d in draggable) {				if(d.IsDragged()) { // if any object is dragged, don't move the camera					somethingIsDragged = true;					return;							} else {					if(somethingIsDragged) {						somethingIsDragged = false;						touchBlocked = true;						StartCoroutine(UnblockTouchHack());					}				}			}			/// keyboard handling			if (Input.GetKeyDown(KeyCode.LeftArrow) && !freeMove)				MoveLeft();			if (Input.GetKeyDown(KeyCode.RightArrow) && !freeMove)				MoveRight();			// touch handling			if (Input.touchCount > 0 && !isPlacing && !freeMove) {				Touch touch = Input.GetTouch(0);				switch (touch.phase) {					case TouchPhase.Began:						startPos = touch.position;						break;					case TouchPhase.Ended:						endPos = touch.position;						StaticMove();						break;				}			}			if (Input.touchCount > 0 && !isPlacing && freeMove) {				Touch touch = Input.GetTouch(0);				switch (touch.phase) {					case TouchPhase.Began:						startPos = touch.position;						lastPos = touch.position;						break;					case TouchPhase.Moved:						FreeMove(new Vector3((touch.position.x - lastPos.x) * factor, (touch.position.y - lastPos.y) * factor, 0f));						lastPos = touch.position;						break;					case TouchPhase.Ended:						endPos = touch.position;						break;				}			}			// smoothly move the camera with each update if smooth move enabled			if(smoothMove)				SmoothMove();		}		IEnumerator UnblockTouchHack() {			yield return new WaitForSeconds(.2f);			touchBlocked = false;		}		private void SmoothMove() {			if (cameraMovementFraction < 1) {				cameraMovementFraction += Time.deltaTime * cameraMovementSpeed;				transform.position = Vector3.Lerp(cameraStart, cameraDestination, cameraMovementFraction);			}		}		private void MoveRight() {			if (currentCameraStepIndex < cameraSteps.Length - 1) {				currentCameraStepIndex++;				Vector3 next = new Vector3(cameraSteps[currentCameraStepIndex].position.x, transform.position.y, transform.position.z);				if (smoothMove) {					cameraStart = transform.position;					cameraDestination = next;						cameraMovementFraction = 0;				} else{					transform.position = next;				}			}		}		private void MoveLeft() {			if (currentCameraStepIndex > 0) {				currentCameraStepIndex--;				Vector3 next = new Vector3(cameraSteps[currentCameraStepIndex].position.x, transform.position.y,  transform.position.z);				if (smoothMove) {					cameraStart = transform.position;					cameraDestination = next;					cameraMovementFraction = 0;				} else {					transform.position = next;				}			}		}		void StaticMove() {			if(touchBlocked)				return;			if (startPos.x > endPos.x) {				MoveRight();			} else if (startPos.x < endPos.x) {				MoveLeft();			}		}		public void SetisPlacing(bool inc) {			isPlacing = inc;		}		void FreeMove(Vector3 vec) {			transform.position -= vec;		}	}}