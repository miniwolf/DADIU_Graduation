using UnityEngine;using System.Collections;public class MainCamera : MonoBehaviour {    public float cameraMovementSpeed = .5f;    public bool smoothMove = true;    public float factor;    public bool isPlacing = false;	public Transform[] cameraSteps = new Transform[10];	private Vector3 startPos, endPos;	private bool freeMove = false;	Vector3 lastPos;    private int currentCameraStepIndex = 0;    private Vector3 cameraStart;    private Vector3 cameraDestination;    private float cameraMovementFraction = 1;    // Update is called once per frame	void Update() {	    /// keyboard handling	    if (Input.GetKeyDown(KeyCode.LeftArrow) && !freeMove)	        MoveLeft();	    if (Input.GetKeyDown(KeyCode.RightArrow) && !freeMove)	        MoveRight();	    // touch handling	    if (Input.touchCount > 0 && !isPlacing && !freeMove) {			Touch touch = Input.GetTouch(0);			switch (touch.phase) {				case TouchPhase.Began:					startPos = touch.position;					break;				case TouchPhase.Ended:					endPos = touch.position;					StaticMove();					break;			}		}	    if (Input.touchCount > 0 && !isPlacing && freeMove) {			Touch touch = Input.GetTouch(0);			switch (touch.phase) {				case TouchPhase.Began:					startPos = touch.position;					lastPos = touch.position;					break;				case TouchPhase.Moved:					FreeMove(new Vector3((touch.position.x - lastPos.x) * factor, (touch.position.y - lastPos.y) * factor, 0f));					lastPos = touch.position;					break;				case TouchPhase.Ended:					endPos = touch.position;					break;			}		}	    if(smoothMove)	        SmoothMove();	}    private void SmoothMove() {        if (cameraMovementFraction < 1) {            cameraMovementFraction += Time.deltaTime * cameraMovementSpeed;            transform.position = Vector3.Lerp(cameraStart, cameraDestination, cameraMovementFraction);        }    }    private void MoveRight() {        if (currentCameraStepIndex < cameraSteps.Length - 1) {            currentCameraStepIndex++;           Vector3 next = new Vector3(cameraSteps[currentCameraStepIndex].position.x, transform.position.y, cameraSteps[currentCameraStepIndex].position.z);            if (smoothMove) {                cameraStart = transform.position;                cameraDestination = next;                    cameraMovementFraction = 0;            } else{                transform.position = next;            }        }    }    private void MoveLeft() {        if (currentCameraStepIndex > 0) {            currentCameraStepIndex--;            Vector3 next = new Vector3(cameraSteps[currentCameraStepIndex].position.x, transform.position.y, cameraSteps[currentCameraStepIndex].position.z);            if (smoothMove) {                cameraStart = transform.position;                cameraDestination = next;                cameraMovementFraction = 0;            } else {                transform.position = next;            }        }    }    void StaticMove() {		if (startPos.x > endPos.x) {		    MoveRight();//			if (currentCameraStepIndex < cameraSteps.Length - 1) {//				currentCameraStepIndex++;//				transform.position = cameraSteps[currentCameraStepIndex].position;//			}		} else if (startPos.x < endPos.x) {		    MoveLeft();//			if (currentCameraStepIndex > 0) {//				currentCameraStepIndex--;//				transform.position = cameraSteps[currentCameraStepIndex].position;//			}		}	}	public void SetisPlacing(bool inc) {		isPlacing = inc;	}	void FreeMove(Vector3 vec) {		transform.position -= vec;	}}